<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Hedron</title>
	<meta content="script-src 'self' 'unsafe-inline';" http-equiv="Content-Security-Policy" />
	<script src="figure.js" type="text/javascript"></script>
	<link href="https://fonts.gstatic.com" rel="preconnect">
	<link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css2?family=Nova+Mono&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap" rel="stylesheet">
	<link href="node_modules/@fortawesome/fontawesome-free/css/all.css" rel="stylesheet" type="text/css">
	<link href="styles/bootstrap_3_3_7.css" rel="stylesheet" type="text/css">
	<link href="theme.css" rel="stylesheet" type="text/css">
</head>
<body>
	<div class="container-fluid">
		<div class="container">
			<div style="height: 25px"></div>
			<div style="height: 25px"></div>
			<div class="center">
				<div class="document document_medium">
					<div id="output-title"></div>
				</div>
			</div>
		</div> <!-- end container -->
	</div> <!-- end container-fluid -->
	<script>

		let window_width = 0;
		let window_height = 0;
		let figure = new FIGURE();

		///////////////////////////////////////////////////////////////////////////
		// IPC COMMUNICATION //////////////////////////////////////////////////////

		window.api.receive('toRender', async (arg) => {
			console.log(arg);
			if (arg.command) {
				switch (arg.command) {

					// core commands
					case 'bounce': { window.api.send('toMain', { command: arg.subcommand, success: arg.success, data: arg.data }); break; }
					case 'console.log': { console.log(arg.data); break; }
					case 'initialize': {
						window_height = arg.height;
						window_width = arg.width;
						break;
					}
					case 'window_resize': {
						window_height = arg.height;
						window_width = arg.width;
						break;
					}

					//aplication-specific commands
					case 'signalink': {
						// create an array of unique identifiers
						let directory = [];
						for (let i = 0; i < arg.data.length; i++) {
							directory.push(arg.data[i].source_uniprotAC);
							directory.push(arg.data[i].target_uniprotAC);
						}
						directory = Array.from(new Set(directory));
						// create an array of NODE objects (one for each unique identifier)
						const nodes = [];
						for (let i = 0; i < directory.length; i++) {
							const node = new NODE();
							node.id = directory[i];
							// find all outgoing edges
							let records = arg.data.filter((x) => { return x.source_uniprotAC === directory[i]; });
							if (records.length) {
								node.name = records[0].source_name;
								for (let j = 0; j < records.length; j++) {
									const edge = new EDGE();
									edge.index = directory.indexOf(records[j].target_uniprotAC);
									edge.id = records[j].target_uniprotAC;
									node.edges.outgoing.push(edge);
								}
							}
							// find all incoming edges
							records = arg.data.filter((x) => { return x.target_uniprotAC === directory[i]; });
							if (records.length) {
								for (let j = 0; j < records.length; j++) {
									const edge = new EDGE();
									edge.index = directory.indexOf(records[j].source_uniprotAC);
									edge.id = records[j].source_uniprotAC;
									node.edges.incoming.push(edge);
								}
							}
							nodes.push(node);
						}
						const network = figure.network(nodes);
						document.body.append(network);
						break;
					}

					default: { break; }

				} 
			}
		});

	</script>
</body>
</html>